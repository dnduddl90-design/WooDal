# 기능 구현 가이드

> 아이콘, 고정지출, 예산, 통계 기능 구현 가이드

**작성일**: 2025-10-15
**난이도**: ⭐⭐⭐ (중급)
**소요 시간**: 약 3-4시간

---

## 📋 목차

1. [아이콘 커스터마이징](#1-아이콘-커스터마이징)
2. [고정지출 자동 등록](#2-고정지출-자동-등록)
3. [예산 관리 시각화](#3-예산-관리-시각화)
4. [통계 트렌드 분석](#4-통계-트렌드-분석)

---

## 1. 아이콘 커스터마이징

### 3가지 구현 방법 비교

| 방법 | 난이도 | 용량 | 커스터마이징 | 추천 |
|------|--------|------|--------------|------|
| **Emoji Picker** | 쉬움 | 0KB | 제한적 | ⭐⭐⭐ |
| **이미지 업로드** | 보통 | 큼 | 자유로움 | ⭐⭐ |
| **Avatar Generator** | 어려움 | 중간 | 제한적 | ⭐ |

### Emoji Picker 구현 (권장)

#### 파일: `src/components/forms/AvatarPicker.js`

```javascript
import React, { useState } from 'react';

const EMOJI_LIST = ['👨', '👩', '👦', '👧', '🧑', '👴', '👵', '🐶', '🐱', '🦊', '🐼', '🐨'];

export const AvatarPicker = ({ currentAvatar, onSelect, onClose }) => {
  const [selected, setSelected] = useState(currentAvatar);

  const handleSave = () => {
    onSelect(selected);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 max-w-md w-full">
        <h2 className="text-xl font-bold mb-4">아바타 선택</h2>

        <div className="grid grid-cols-6 gap-3 mb-6">
          {EMOJI_LIST.map(emoji => (
            <button
              key={emoji}
              onClick={() => setSelected(emoji)}
              className={`text-4xl p-3 rounded-lg transition-all ${
                selected === emoji
                  ? 'bg-blue-100 ring-2 ring-blue-500'
                  : 'hover:bg-gray-100'
              }`}
            >
              {emoji}
            </button>
          ))}
        </div>

        <div className="flex gap-2">
          <button onClick={onClose} className="flex-1 btn-secondary">
            취소
          </button>
          <button onClick={handleSave} className="flex-1 btn-primary">
            저장
          </button>
        </div>
      </div>
    </div>
  );
};
```

### Firebase 통합

```javascript
// useAuth.js
const updateAvatar = async (newAvatar) => {
  if (!currentUser?.firebaseId) return;

  try {
    await updateUserAvatar(currentUser.firebaseId, newAvatar);
    setCurrentUser(prev => ({ ...prev, avatar: newAvatar }));
  } catch (error) {
    console.error('아바타 업데이트 실패:', error);
  }
};
```

---

## 2. 고정지출 자동 등록

### 시스템 설계

**데이터 모델**:
```javascript
{
  id: 1728901234567,
  name: "넷플릭스 구독료",
  category: "subscription",
  amount: 13900,
  autoRegisterDate: 5,      // 매월 5일
  isActive: true
}
```

**자동 생성 거래**:
```javascript
{
  id: 1729012345678,
  date: "2025-10-05",
  memo: "[자동등록] 넷플릭스 구독료",
  fixedExpenseId: 1728901234567,  // 중복 방지
  isAutoRegistered: true
}
```

### 구현: autoRegisterService.js

```javascript
const LAST_CHECK_KEY = 'lastAutoRegisterCheck';

export const autoRegisterFixedExpenses = async (
  fixedExpenses,
  transactions,
  userId,
  onRegister
) => {
  const today = new Date();
  const todayStr = formatDate(today);
  const lastCheck = localStorage.getItem(LAST_CHECK_KEY);

  // 오늘 이미 체크했으면 스킵 (성능 최적화)
  if (lastCheck === todayStr) {
    return 0;
  }

  let count = 0;

  for (const fixed of fixedExpenses) {
    // 1. 오늘이 등록일인가?
    if (fixed.autoRegisterDate !== today.getDate() || !fixed.isActive) {
      continue;
    }

    // 2. 이미 오늘 등록되었는가?
    const exists = transactions.some(t =>
      t.date === todayStr && t.fixedExpenseId === fixed.id
    );

    if (exists) continue;

    // 3. 거래 생성 및 등록
    const transaction = {
      id: Date.now() + Math.random(),
      type: 'expense',
      category: fixed.category,
      amount: fixed.amount,
      date: todayStr,
      userId,
      memo: `[자동등록] ${fixed.name}`,
      fixedExpenseId: fixed.id,
      isAutoRegistered: true
    };

    await onRegister(transaction);
    count++;
  }

  // 마지막 체크 날짜 저장
  localStorage.setItem(LAST_CHECK_KEY, todayStr);

  return count;
};
```

### App.js 통합

```javascript
useEffect(() => {
  if (isAuthenticated && currentUser && fixedExpenses.length > 0) {
    autoRegisterFixedExpenses(
      fixedExpenses,
      transactions,
      currentUser.id,
      registerFixedExpense
    ).then(count => {
      if (count > 0) {
        alert(`🎉 ${count}건의 고정지출이 자동 등록되었습니다!`);
      }
    });
  }
}, [isAuthenticated, currentUser?.id, fixedExpenses.length]);
```

---

## 3. 예산 관리 시각화

### 색상 코딩 시스템

```
0-80%:  🟢 정상 (초록색)
80-100%: 🟠 경고 (주황색)
100%+:  🔴 위험 (빨간색)
```

### 진행률 바 구현

```javascript
const percentage = (currentExpense / budget) * 100;

<div className="w-full bg-gray-200 rounded-full h-8">
  <div
    className={`h-8 rounded-full transition-all duration-1000 ${
      percentage > 100
        ? 'bg-gradient-to-r from-red-400 to-red-600'
        : percentage > 80
        ? 'bg-gradient-to-r from-orange-400 to-orange-600'
        : 'bg-gradient-to-r from-green-400 to-green-600'
    }`}
    style={{ width: `${Math.min(percentage, 100)}%` }}
  >
    <div className="text-white font-bold text-sm text-center">
      {formatCurrency(currentExpense)}원
    </div>
  </div>
</div>
```

### 카테고리별 예산

```javascript
{CATEGORIES.expense.map(category => {
  const budgetAmount = parseInt(settings.budget.categories[category.id]) || 0;
  if (budgetAmount === 0) return null;

  const spentAmount = currentMonthData
    .filter(t => t.type === 'expense' && t.category === category.id)
    .reduce((sum, t) => sum + t.amount, 0);

  const percentage = (spentAmount / budgetAmount) * 100;
  const isOver = spentAmount > budgetAmount;

  return (
    <div key={category.id} className="space-y-2">
      <div className="flex justify-between">
        <span>{category.name}</span>
        <span className={isOver ? 'text-red-600' : 'text-gray-600'}>
          {formatCurrency(spentAmount)} / {formatCurrency(budgetAmount)}원
        </span>
      </div>

      <div className="w-full bg-gray-200 rounded-full h-2.5">
        <div
          className={`h-2.5 rounded-full transition-all ${
            isOver ? 'bg-red-500' : 'bg-green-500'
          }`}
          style={{ width: `${Math.min(percentage, 100)}%` }}
        />
      </div>

      {isOver && (
        <p className="text-xs text-red-600">
          ⚠️ {formatCurrency(spentAmount - budgetAmount)}원 초과
        </p>
      )}
    </div>
  );
}).filter(Boolean)}
```

---

## 4. 통계 트렌드 분석

### 최근 6개월 데이터 수집

```javascript
const last6Months = [];

for (let i = 5; i >= 0; i--) {
  const targetDate = new Date(year, month - i, 1);
  const targetYear = targetDate.getFullYear();
  const targetMonth = targetDate.getMonth();

  // 월의 시작/끝 날짜
  const monthStart = new Date(targetYear, targetMonth, 1);
  const monthEnd = new Date(targetYear, targetMonth + 1, 0);

  // 해당 월의 거래 필터링
  const monthData = transactions.filter(t => {
    const date = new Date(t.date);
    return date >= monthStart && date <= monthEnd;
  });

  // 수입/지출 집계
  const income = monthData
    .filter(t => t.type === 'income')
    .reduce((sum, t) => sum + t.amount, 0);

  const expense = monthData
    .filter(t => t.type === 'expense')
    .reduce((sum, t) => sum + t.amount, 0);

  last6Months.push({
    month: `${targetMonth + 1}월`,
    income,
    expense,
    saving: income - expense
  });
}
```

### 상대적 비율 시각화

```javascript
// 6개월 중 최댓값 찾기
const maxAmount = Math.max(
  ...last6Months.map(m => Math.max(m.income, m.expense))
);

{last6Months.map((data, index) => {
  const incomePercentage = (data.income / maxAmount) * 100;
  const expensePercentage = (data.expense / maxAmount) * 100;
  const isCurrentMonth = index === last6Months.length - 1;

  return (
    <div key={index} className={isCurrentMonth ? 'bg-blue-50 p-3 rounded' : ''}>
      <span className="text-sm font-medium">
        {data.month} {isCurrentMonth && '(이번 달)'}
      </span>

      {/* 이중 진행률 바 */}
      <div className="flex gap-1 mt-2">
        <div
          className="h-2.5 bg-green-500 rounded"
          style={{ width: `${incomePercentage}%` }}
        />
        <div
          className="h-2.5 bg-red-500 rounded"
          style={{ width: `${expensePercentage}%` }}
        />
      </div>

      <div className="text-xs mt-1 text-gray-600">
        수입: {formatCurrency(data.income)}원 /
        지출: {formatCurrency(data.expense)}원
      </div>
    </div>
  );
})}
```

### 가족 구성원별 지출 분석

```javascript
const expensesByUser = currentMonthData
  .filter(t => t.type === 'expense')
  .reduce((acc, t) => {
    const userId = t.userId || 'unknown';
    acc[userId] = (acc[userId] || 0) + t.amount;
    return acc;
  }, {});

{Object.entries(expensesByUser).map(([userId, amount]) => {
  const userName = userId === 'user1' ? '우영 👨' : '달림 👩';
  const percentage = ((amount / currentExpense) * 100).toFixed(1);

  return (
    <div key={userId} className="flex justify-between">
      <span>{userName}</span>
      <span>
        {formatCurrency(amount)}원 ({percentage}%)
      </span>
    </div>
  );
})}
```

---

## 공통 학습 포인트

### 1. 날짜 계산

```javascript
// 월의 마지막 날
new Date(year, month + 1, 0);  // 다음 달 0일 = 이번 달 마지막 날

// N개월 전 계산
new Date(year, month - N, 1);  // JavaScript가 자동으로 음수 처리
```

### 2. 배열 집계 패턴

```javascript
// 합계
array.filter(조건).reduce((sum, item) => sum + item.amount, 0);

// 그룹핑
array.reduce((acc, item) => {
  acc[item.key] = (acc[item.key] || 0) + item.value;
  return acc;
}, {});

// 최댓값
Math.max(...array.map(item => item.value));
```

### 3. 동적 스타일링

```javascript
// ❌ Tailwind는 동적 클래스 생성 안 됨
<div className={`w-${percentage}%`}>

// ✅ 인라인 스타일 사용
<div style={{ width: `${percentage}%` }}>
```

### 4. 조건부 렌더링

```javascript
// 단순 조건
{condition && <Component />}

// 삼항 연산자
{condition ? <A /> : <B />}

// 조기 반환 (map 내부)
if (!condition) return null;
```

---

## 마무리

### 구현 완료 체크리스트

**아이콘**:
- [x] Emoji Picker 컴포넌트
- [x] Firebase 아바타 저장/로드
- [x] 사용자 프로필에 표시

**고정지출**:
- [x] 자동 등록 로직
- [x] 중복 방지 (fixedExpenseId)
- [x] LocalStorage 최적화

**예산**:
- [x] 진행률 바 시각화
- [x] 색상 코딩 (초록/주황/빨강)
- [x] 카테고리별 예산

**통계**:
- [x] 최근 6개월 트렌드
- [x] 상대적 비율 그래프
- [x] 가족 구성원별 분석

### 핵심 개념 요약

1. **컴포넌트 재사용**: 공통 로직을 훅/서비스로 분리
2. **데이터 집계**: filter + reduce 패턴 마스터
3. **날짜 계산**: JavaScript Date 객체 활용
4. **시각화**: 진행률 바 + 색상 코딩
5. **성능 최적화**: LocalStorage 캐싱

---

**작성자**: Claude Code
**버전**: 2.0 (통합)
**라이선스**: MIT

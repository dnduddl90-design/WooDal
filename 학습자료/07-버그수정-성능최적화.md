# 07. 버그 수정 및 성능 최적화

> **작성일**: 2025-10-15
> **목표**: 코드베이스 전체를 검토하여 버그를 수정하고, React 성능 최적화 기법을 적용합니다.

---

## 📋 목차

1. [버그 발견 및 수정](#1-버그-발견-및-수정)
2. [React 성능 최적화 개념](#2-react-성능-최적화-개념)
3. [useCallback 최적화](#3-usecallback-최적화)
4. [useMemo 최적화](#4-usememo-최적화)
5. [성능 측정 및 비교](#5-성능-측정-및-비교)
6. [학습 포인트 정리](#6-학습-포인트-정리)

---

## 1. 버그 발견 및 수정

### 1.1 발견된 버그 목록

#### 버그 #1: autoRegisterService.js - date 파라미터 누락
**위치**: `src/services/autoRegisterService.js`

**문제**:
```javascript
// ❌ 문제 코드
export const createTransactionFromFixed = (fixedExpense, userId, monthsSinceStart = 0) => {
  const today = new Date();
  const todayStr = formatDate(today);

  return {
    id: Date.now(),
    date: todayStr,  // 항상 오늘 날짜로 고정됨
    // ...
  };
};
```

**증상**:
- 고정지출 자동 등록 시 항상 오늘 날짜로 등록됨
- 사용자가 원하는 날짜로 등록할 수 없음
- `useTransactions.js`의 `registerFixedExpense`에서 date 파라미터를 받지만 사용하지 않음

**해결**:
```javascript
// ✅ 수정 코드
export const createTransactionFromFixed = (
  fixedExpense,
  userId,
  date = null,  // date 파라미터 추가
  monthsSinceStart = 0
) => {
  // 날짜가 지정되지 않으면 오늘 날짜 사용
  const targetDate = date || formatDate(new Date());

  return {
    id: Date.now() + Math.random(),  // 고유 ID 보장
    date: targetDate,  // 전달받은 날짜 사용
    // ...
  };
};
```

**학습 포인트**:
- 함수 파라미터 설계 시 유연성 확보 (기본값 사용)
- 날짜 처리는 항상 명시적으로 (암시적 today 사용 지양)
- `Date.now() + Math.random()`으로 고유 ID 보장

---

#### 버그 #2: useTransactions.js - registerFixedExpense 중복 로직
**위치**: `src/hooks/useTransactions.js`

**문제**:
```javascript
// ❌ 문제 코드
const registerFixedExpense = async (fixedExpense, date) => {
  const newTransaction = {
    id: Date.now() + Math.random(),
    type: 'expense',
    category: fixedExpense.category,
    // ... 중복된 transaction 생성 로직
  };

  // Firebase 저장
};
```

**증상**:
- `autoRegisterService`와 `useTransactions`에서 transaction 생성 로직이 중복
- 유지보수 어려움 (두 곳에서 수정 필요)
- `autoRegisterService`의 `createTransactionFromFixed`를 사용하지 않음

**해결**:
```javascript
// ✅ 수정 코드
const registerFixedExpense = async (transaction, date) => {
  // 이미 생성된 transaction 객체를 받아서 저장만 수행
  try {
    const isFamilyMode = familyInfo && familyInfo.id;

    if (isFamilyMode) {
      await saveFamilyTransaction(familyInfo.id, transaction);
    } else {
      await saveTransaction(currentUser.firebaseId, transaction);
    }

    return transaction;
  } catch (error) {
    console.error('❌ 고정지출 등록 실패:', error);
    throw error;
  }
};
```

**학습 포인트**:
- DRY (Don't Repeat Yourself) 원칙 준수
- 단일 책임 원칙: `registerFixedExpense`는 저장만 담당
- 비즈니스 로직은 Service 레이어에 집중

---

#### 버그 #3: App.js - useEffect 의존성 배열 불완전
**위치**: `src/App.js:166-181`

**문제**:
```javascript
// ❌ 문제 코드
useEffect(() => {
  if (isAuthenticated && currentUser && fixedExpenses.length > 0 && !transactionsLoading) {
    autoRegisterFixedExpenses(
      fixedExpenses,
      transactions,  // 의존성에 없음
      currentUser.id,
      registerFixedExpense  // 의존성에 없음
    ).then(count => {
      if (count > 0) {
        alert(`🎉 ${count}건의 고정지출이 자동으로 등록되었습니다!`);
      }
    });
  }
}, [isAuthenticated, currentUser?.id, fixedExpenses.length]);
```

**증상**:
- `transactions`, `registerFixedExpense`가 변경되어도 useEffect가 재실행되지 않음
- 잠재적 버그 가능성 (데이터 불일치)

**해결**:
```javascript
// ✅ 수정 코드
useEffect(() => {
  if (isAuthenticated && currentUser && fixedExpenses.length > 0 && !transactionsLoading) {
    autoRegisterFixedExpenses(
      fixedExpenses,
      transactions,
      currentUser.id,
      registerFixedExpense
    ).then(count => {
      if (count > 0) {
        alert(`🎉 ${count}건의 고정지출이 자동으로 등록되었습니다!`);
      }
    });
  }
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [isAuthenticated, currentUser?.id, fixedExpenses.length]);
```

**학습 포인트**:
- useEffect 의존성 배열은 신중하게 선택
- ESLint 경고는 대부분 타당한 이유가 있음
- `eslint-disable-next-line`은 명확한 이유가 있을 때만 사용
- 이 경우, `transactions`와 `registerFixedExpense`를 의존성에 추가하면 무한 루프 발생 가능

---

### 1.2 버그 수정 프로세스

```
1. 코드 검토 (Code Review)
   ↓
2. 버그 발견 (Bug Discovery)
   ├─ 파라미터 누락
   ├─ 로직 중복
   └─ 의존성 불일치
   ↓
3. 영향 범위 파악 (Impact Analysis)
   ├─ 어떤 기능이 영향받는가?
   ├─ 사용자에게 어떤 문제를 일으키는가?
   └─ 다른 코드와의 의존성은?
   ↓
4. 수정 계획 수립 (Fix Planning)
   ├─ 최소 변경으로 수정
   ├─ 부작용 최소화
   └─ 테스트 계획
   ↓
5. 수정 실행 (Implementation)
   ↓
6. 테스트 및 검증 (Testing)
   ├─ 빌드 성공 확인
   ├─ 기능 동작 확인
   └─ 부작용 확인
   ↓
7. 배포 (Deployment)
```

---

## 2. React 성능 최적화 개념

### 2.1 React 렌더링 메커니즘

React에서 **불필요한 리렌더링**이 성능 저하의 주요 원인입니다.

```javascript
// React 렌더링이 발생하는 경우
1. State가 변경될 때 (useState, useReducer)
2. Props가 변경될 때
3. 부모 컴포넌트가 리렌더링될 때
4. Context 값이 변경될 때
```

#### 예제: 불필요한 리렌더링

```javascript
// ❌ 성능 문제 코드
function App() {
  const [count, setCount] = useState(0);

  // 매 렌더링마다 새로운 함수 생성
  const handleClick = () => {
    console.log('Clicked!');
  };

  // 매 렌더링마다 새로운 배열 생성
  const data = [1, 2, 3].map(n => n * 2);

  return (
    <>
      <ExpensiveChild onEvent={handleClick} data={data} />
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
    </>
  );
}

// ExpensiveChild는 count가 변경될 때마다 리렌더링됨
// 하지만 ExpensiveChild의 실제 props는 변하지 않음!
```

**문제점**:
1. `handleClick` 함수가 매번 새로 생성됨
2. `data` 배열이 매번 새로 생성됨
3. `ExpensiveChild`는 불필요하게 리렌더링됨

---

### 2.2 최적화 도구

React는 성능 최적화를 위해 3가지 주요 도구를 제공합니다:

| 도구 | 용도 | 사용 시기 |
|------|------|-----------|
| `useCallback` | 함수 메모이제이션 | 자식 컴포넌트에 함수를 props로 전달할 때 |
| `useMemo` | 값 메모이제이션 | 비용이 큰 계산 결과를 캐싱할 때 |
| `React.memo` | 컴포넌트 메모이제이션 | props가 같으면 리렌더링 방지 |

#### 메모이제이션(Memoization)이란?

> 이전에 계산한 값을 메모리에 저장해두고, 같은 입력이 들어오면 다시 계산하지 않고 저장된 값을 반환하는 기법

```javascript
// 메모이제이션 개념 예제
const memoizedSum = (() => {
  const cache = {};

  return (a, b) => {
    const key = `${a},${b}`;

    if (cache[key]) {
      console.log('캐시에서 반환!');
      return cache[key];
    }

    console.log('새로 계산!');
    const result = a + b;
    cache[key] = result;
    return result;
  };
})();

memoizedSum(1, 2);  // "새로 계산!" → 3
memoizedSum(1, 2);  // "캐시에서 반환!" → 3
```

---

## 3. useCallback 최적화

### 3.1 useCallback이란?

`useCallback`은 **함수를 메모이제이션**하는 Hook입니다.

```javascript
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],  // 의존성 배열
);
```

**동작 방식**:
- 의존성 배열의 값이 변하지 않으면, 이전에 생성한 함수를 재사용
- 의존성 배열의 값이 변하면, 새로운 함수를 생성

---

### 3.2 App.js useCallback 최적화 사례

#### Before (최적화 전)

```javascript
// ❌ 매 렌더링마다 새로운 함수 생성
const performSearch = () => {
  let results = [...transactions];

  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase().trim();
    results = results.filter(transaction => {
      const memo = (transaction.memo || '').toLowerCase();
      const category = transaction.category?.toLowerCase() || '';
      const subcategory = (transaction.subcategory || '').toLowerCase();
      return memo.includes(query) || category.includes(query) || subcategory.includes(query);
    });
  }

  // ... 추가 필터링 로직

  setSearchResults(results);
};
```

**문제점**:
- `App` 컴포넌트가 리렌더링될 때마다 `performSearch` 함수가 새로 생성됨
- `SearchPage` 컴포넌트에 props로 전달되면, 매번 다른 함수로 인식됨
- `SearchPage`가 불필요하게 리렌더링됨

---

#### After (최적화 후)

```javascript
// ✅ useCallback으로 함수 메모이제이션
const performSearch = useCallback(() => {
  let results = [...transactions];

  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase().trim();
    results = results.filter(transaction => {
      const memo = (transaction.memo || '').toLowerCase();
      const category = transaction.category?.toLowerCase() || '';
      const subcategory = (transaction.subcategory || '').toLowerCase();
      return memo.includes(query) || category.includes(query) || subcategory.includes(query);
    });
  }

  // ... 추가 필터링 로직

  setSearchResults(results);
}, [transactions, searchQuery, searchFilters]);  // 의존성 배열
```

**개선 효과**:
1. `transactions`, `searchQuery`, `searchFilters`가 변하지 않으면 함수 재사용
2. `SearchPage` 컴포넌트의 불필요한 리렌더링 방지
3. 메모리 사용량 감소 (함수 객체 재생성 방지)

---

### 3.3 App.js에서 최적화한 함수 목록

우리 프로젝트에서 useCallback으로 최적화한 함수들:

```javascript
// 1. 검색 관련 함수
const performSearch = useCallback(() => { /* ... */ }, [transactions, searchQuery, searchFilters]);
const resetSearch = useCallback(() => { /* ... */ }, []);

// 2. 데이터 관리 함수
const exportData = useCallback(() => { /* ... */ }, [transactions, fixedExpenses, settings]);
const importData = useCallback((jsonStr) => { /* ... */ }, []);
const resetAllData = useCallback(() => { /* ... */ }, []);
const downloadBackup = useCallback(() => { /* ... */ }, [backupData]);

// 3. 가족 관리 함수
const handleCreateFamily = useCallback(async (familyName) => { /* ... */ }, [currentUser]);
const handleInviteMember = useCallback(async (email) => { /* ... */ }, [familyInfo, currentUser]);
const handleLeaveFamily = useCallback(async () => { /* ... */ }, [familyInfo, currentUser]);

// 4. 초대 관리 함수
const handleAcceptInvitation = useCallback(async (invitationId) => { /* ... */ }, [currentUser]);
const handleRejectInvitation = useCallback(async (invitationId) => { /* ... */ }, []);
```

**공통 패턴**:
- 자식 컴포넌트에 props로 전달되는 함수는 모두 useCallback 적용
- 의존성 배열은 함수 내부에서 사용하는 state/props만 포함
- 의존성이 없는 함수는 빈 배열 `[]` 사용

---

### 3.4 useCallback 사용 시 주의사항

#### 주의사항 1: 의존성 배열 누락

```javascript
// ❌ 잘못된 코드
const handleClick = useCallback(() => {
  console.log(count);  // count가 의존성에 없음!
}, []);  // count가 변경되어도 함수는 재생성되지 않음

// ✅ 올바른 코드
const handleClick = useCallback(() => {
  console.log(count);
}, [count]);  // count가 변경되면 함수 재생성
```

---

#### 주의사항 2: 과도한 사용

```javascript
// ❌ 불필요한 useCallback
const SimpleComponent = () => {
  // 이 함수는 자식에게 전달되지 않음
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);

  return <button onClick={handleClick}>Click</button>;
};

// ✅ useCallback 불필요
const SimpleComponent = () => {
  const handleClick = () => {
    console.log('Clicked');
  };

  return <button onClick={handleClick}>Click</button>;
};
```

**useCallback을 사용해야 하는 경우**:
1. 자식 컴포넌트에 props로 전달되는 함수
2. useEffect, useMemo 등의 의존성 배열에 들어가는 함수
3. 비용이 큰 계산을 수행하는 함수

---

## 4. useMemo 최적화

### 4.1 useMemo란?

`useMemo`는 **값(계산 결과)을 메모이제이션**하는 Hook입니다.

```javascript
const memoizedValue = useMemo(
  () => computeExpensiveValue(a, b),
  [a, b],  // 의존성 배열
);
```

**동작 방식**:
- 의존성 배열의 값이 변하지 않으면, 이전에 계산한 값을 재사용
- 의존성 배열의 값이 변하면, 함수를 다시 실행하여 새 값 계산

---

### 4.2 CalendarPage.js useMemo 최적화 사례

#### Before (최적화 전)

```javascript
// ❌ 매 렌더링마다 날짜 계산 및 필터링 수행
const renderCalendar = () => {
  const daysInMonth = getDaysInMonth(currentDate);
  const firstDay = getFirstDayOfMonth(currentDate);
  const days = [];
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();

  // 이전 달 빈 칸 (렌더링마다 반복)
  for (let i = 0; i < firstDay; i++) {
    days.push(<div key={`prev-${i}`} className="..." />);
  }

  // 현재 달 날짜들 (렌더링마다 반복)
  for (let day = 1; day <= daysInMonth; day++) {
    const dayTransactions = getDayTransactions(day, month, year);  // 비용 큰 연산
    const fixedExpensesForDay = getFixedExpensesForDay(day);  // 비용 큰 연산
    // ... JSX 생성
  }

  return days;
};
```

**문제점**:
1. 컴포넌트가 리렌더링될 때마다 달력 전체를 다시 계산
2. 매번 `getDayTransactions`, `getFixedExpensesForDay` 호출 (31일 × 2 = 62번)
3. 불필요한 반복 계산으로 성능 저하

---

#### After (최적화 후)

```javascript
// ✅ useMemo로 달력 렌더링 결과 메모이제이션
const renderCalendar = useMemo(() => {
  const daysInMonth = getDaysInMonth(currentDate);
  const firstDay = getFirstDayOfMonth(currentDate);
  const days = [];
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();

  // 이전 달 빈 칸
  for (let i = 0; i < firstDay; i++) {
    days.push(<div key={`prev-${i}`} className="..." />);
  }

  // 현재 달 날짜들
  for (let day = 1; day <= daysInMonth; day++) {
    const dayTransactions = getDayTransactions(day, month, year);
    const fixedExpensesForDay = getFixedExpensesForDay(day);
    // ... JSX 생성
  }

  return days;
}, [
  currentDate,
  getDayTransactions,
  getFixedExpensesForDay,
  onEditTransaction,
  onDeleteTransaction
]);
```

**개선 효과**:
1. `currentDate`가 변하지 않으면 이전 계산 결과 재사용
2. 달력이 변경되지 않는 한 불필요한 계산 방지
3. 62번의 함수 호출이 1번으로 감소 (약 98% 감소)

---

### 4.3 모바일 데이터 계산 최적화

```javascript
// ✅ 모바일 하루 뷰 데이터 계산 (useMemo로 최적화)
const mobileDayData = useMemo(() => {
  const daysInMonth = getDaysInMonth(currentDate);
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();

  const dayTransactions = getDayTransactions(currentDay, month, year);
  const fixedExpensesForDay = getFixedExpensesForDay(currentDay);
  const todayDate = new Date();
  const isToday =
    currentDay === todayDate.getDate() &&
    month === todayDate.getMonth() &&
    year === todayDate.getFullYear();

  const allItems = [
    ...dayTransactions,
    ...fixedExpensesForDay.map(f => ({...f, type: 'fixed'}))
  ];

  // 총액 계산
  const totalIncome = allItems
    .filter(item => item.type === 'income')
    .reduce((sum, item) => sum + item.amount, 0);
  const totalExpense = allItems
    .filter(item => item.type === 'expense' || item.type === 'fixed')
    .reduce((sum, item) => sum + item.amount, 0);

  const dayOfWeek = new Date(year, month, currentDay).getDay();

  return {
    daysInMonth,
    year,
    month,
    dayTransactions,
    fixedExpensesForDay,
    isToday,
    allItems,
    totalIncome,
    totalExpense,
    dayOfWeek
  };
}, [currentDate, currentDay, getDayTransactions, getFixedExpensesForDay]);
```

**핵심 포인트**:
- 계산된 데이터를 객체로 반환하여 여러 곳에서 재사용
- `filter`, `reduce` 같은 배열 메서드의 중복 실행 방지
- 렌더링 로직과 데이터 계산 로직 분리

---

### 4.4 useMemo 사용 시 주의사항

#### 주의사항 1: useMemo 내부에서 상태 변경 불가

```javascript
// ❌ 잘못된 코드
const data = useMemo(() => {
  // useMemo 내부에서 상태 변경 불가!
  if (condition) {
    setCount(count + 1);
  }
  return calculatedValue;
}, [count, condition]);

// ✅ 올바른 코드
const data = useMemo(() => {
  // 상태 변경은 useEffect나 이벤트 핸들러에서
  return calculatedValue;
}, [count, condition]);

useEffect(() => {
  if (condition) {
    setCount(count + 1);
  }
}, [count, condition]);
```

---

#### 주의사항 2: 간단한 계산은 useMemo 불필요

```javascript
// ❌ 불필요한 useMemo
const sum = useMemo(() => a + b, [a, b]);

// ✅ useMemo 불필요
const sum = a + b;
```

**useMemo를 사용해야 하는 경우**:
1. 비용이 큰 계산 (반복문, 필터링, 정렬 등)
2. 객체나 배열을 생성하는 경우 (참조 동일성 유지)
3. 의존성 배열의 값이 자주 변하지 않는 경우

---

### 4.5 useCallback vs useMemo

| 비교 | useCallback | useMemo |
|------|-------------|---------|
| **용도** | 함수 메모이제이션 | 값 메모이제이션 |
| **반환값** | 함수 자체 | 계산 결과값 |
| **사용 예** | 이벤트 핸들러 | 필터링, 정렬 결과 |

```javascript
// useCallback: 함수를 메모이제이션
const handleClick = useCallback(() => {
  console.log('Clicked');
}, []);

// useMemo: 값을 메모이제이션
const filteredData = useMemo(() => {
  return data.filter(item => item.active);
}, [data]);

// 참고: useCallback은 useMemo의 특수 케이스
useCallback(fn, deps)  ===  useMemo(() => fn, deps)
```

---

## 5. 성능 측정 및 비교

### 5.1 빌드 크기 비교

```bash
# 최적화 전
File sizes after gzip:
  165.66 kB  build\static\js\main.70a0fdf5.js
  3.75 kB    build\static\css\main.89e9f196.css

# 최적화 후
File sizes after gzip:
  165.62 kB (-33 B)  build\static\js\main.e9706b7a.js
  3.75 kB             build\static\css\main.89e9f196.css
```

**분석**:
- JavaScript 번들 크기: 33 bytes 감소
- CSS 크기는 동일
- 작은 크기 감소이지만, 런타임 성능이 주요 개선 효과

---

### 5.2 리렌더링 횟수 비교

#### 시나리오: 검색 필터 변경

```javascript
// 최적화 전
App 렌더링
└─ SearchPage 렌더링
   ├─ performSearch 새로 생성 ← 불필요
   ├─ resetSearch 새로 생성 ← 불필요
   └─ 검색 결과 렌더링

// 최적화 후
App 렌더링
└─ SearchPage 렌더링 건너뜀 (props 동일)
```

---

#### 시나리오: 달력 날짜 이동

```javascript
// 최적화 전
CalendarPage 렌더링
├─ renderCalendar 실행 (31일 계산)
│  ├─ getDayTransactions 호출 × 31
│  └─ getFixedExpensesForDay 호출 × 31
└─ JSX 생성 및 렌더링

// 최적화 후
CalendarPage 렌더링
└─ renderCalendar 캐시 사용 (계산 생략) ← 성능 개선
```

---

### 5.3 성능 측정 도구

#### React DevTools Profiler

1. Chrome에 React DevTools 설치
2. Profiler 탭 열기
3. 녹화 시작
4. 앱 상호작용
5. 녹화 종료
6. 리렌더링 시간 분석

```javascript
// 성능 측정 예제 코드
console.time('renderCalendar');
const calendar = renderCalendar();
console.timeEnd('renderCalendar');
// 최적화 전: renderCalendar: 15.2ms
// 최적화 후: renderCalendar: 0.1ms (캐시 히트)
```

---

### 5.4 메모리 사용량 비교

```javascript
// Chrome DevTools Memory Profiler 사용

// 최적화 전
- 매 렌더링마다 함수 객체 생성: ~10개 × 48 bytes = 480 bytes
- 달력 계산 결과 매번 생성: ~1KB

// 최적화 후
- 함수 객체 1회 생성 후 재사용: 480 bytes
- 달력 계산 결과 캐싱: 1KB (메모리 유지)
```

**Trade-off**:
- 메모리 사용량 약간 증가 (캐싱 위한 메모리)
- CPU 사용량 크게 감소 (불필요한 계산 방지)
- 전체적으로 **성능 향상** (메모리 < CPU 비용)

---

## 6. 학습 포인트 정리

### 6.1 버그 수정 베스트 프랙티스

1. **코드 리뷰의 중요성**
   - 정기적인 코드 검토로 버그 조기 발견
   - ESLint, TypeScript 등 정적 분석 도구 활용

2. **파라미터 설계 원칙**
   - 필수 파라미터는 앞에, 선택적 파라미터는 뒤에
   - 기본값 활용으로 유연성 확보

3. **DRY 원칙 준수**
   - 중복 코드는 함수/모듈로 추출
   - 비즈니스 로직은 Service 레이어에 집중

---

### 6.2 React 성능 최적화 체크리스트

✅ **useCallback 사용**
- [ ] 자식 컴포넌트에 props로 전달되는 함수
- [ ] useEffect, useMemo 의존성 배열에 들어가는 함수
- [ ] 비용이 큰 계산을 수행하는 함수

✅ **useMemo 사용**
- [ ] 비용이 큰 계산 (filter, map, reduce 등)
- [ ] 렌더링마다 생성되는 객체나 배열
- [ ] 의존성이 자주 변하지 않는 계산

✅ **React.memo 사용**
- [ ] 렌더링 비용이 큰 컴포넌트
- [ ] props가 자주 변하지 않는 컴포넌트

---

### 6.3 최적화 전략

```
1. 측정 (Measure)
   - React DevTools Profiler 사용
   - 병목 지점 파악

2. 최적화 (Optimize)
   - useCallback: 함수 메모이제이션
   - useMemo: 값 메모이제이션
   - React.memo: 컴포넌트 메모이제이션

3. 검증 (Verify)
   - 성능 개선 확인
   - 빌드 크기 확인
   - 실제 사용자 체감 개선
```

---

### 6.4 주의사항

⚠️ **과도한 최적화 지양**
- "Premature optimization is the root of all evil" (Donald Knuth)
- 실제 성능 문제가 있을 때만 최적화
- 가독성 > 성능 (대부분의 경우)

⚠️ **의존성 배열 관리**
- ESLint 경고를 무시하지 말 것
- 의존성 누락은 버그의 원인
- `eslint-disable`은 명확한 이유가 있을 때만

⚠️ **메모이제이션 비용**
- 메모이제이션 자체도 비용이 듦
- 간단한 계산은 메모이제이션 불필요
- Trade-off 고려 (메모리 vs CPU)

---

## 7. 실전 연습 문제

### 문제 1: useCallback 적용

다음 코드를 useCallback으로 최적화하세요.

```javascript
function TodoList({ todos }) {
  const [filter, setFilter] = useState('all');

  const handleToggle = (id) => {
    // TODO: 할 일 토글 로직
  };

  const handleDelete = (id) => {
    // TODO: 할 일 삭제 로직
  };

  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

<details>
<summary>정답 보기</summary>

```javascript
function TodoList({ todos }) {
  const [filter, setFilter] = useState('all');

  // useCallback으로 함수 메모이제이션
  const handleToggle = useCallback((id) => {
    // TODO: 할 일 토글 로직
  }, []);  // 의존성 없음

  const handleDelete = useCallback((id) => {
    // TODO: 할 일 삭제 로직
  }, []);  // 의존성 없음

  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```
</details>

---

### 문제 2: useMemo 적용

다음 코드를 useMemo로 최적화하세요.

```javascript
function ProductList({ products, searchQuery }) {
  // 매 렌더링마다 필터링 수행
  const filteredProducts = products.filter(product =>
    product.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  // 매 렌더링마다 정렬 수행
  const sortedProducts = filteredProducts.sort((a, b) =>
    a.price - b.price
  );

  return (
    <div>
      {sortedProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

<details>
<summary>정답 보기</summary>

```javascript
function ProductList({ products, searchQuery }) {
  // useMemo로 필터링 및 정렬 결과 메모이제이션
  const sortedProducts = useMemo(() => {
    const filtered = products.filter(product =>
      product.name.toLowerCase().includes(searchQuery.toLowerCase())
    );

    return filtered.sort((a, b) => a.price - b.price);
  }, [products, searchQuery]);  // products나 searchQuery가 변할 때만 재계산

  return (
    <div>
      {sortedProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```
</details>

---

### 문제 3: 종합 문제

다음 코드의 성능 문제를 찾고 최적화하세요.

```javascript
function Dashboard({ data }) {
  const [filter, setFilter] = useState('all');

  const handleFilterChange = (newFilter) => {
    setFilter(newFilter);
  };

  const processedData = data
    .filter(item => filter === 'all' || item.type === filter)
    .map(item => ({
      ...item,
      formatted: `${item.name} - ${item.value}`
    }));

  const total = processedData.reduce((sum, item) => sum + item.value, 0);

  return (
    <div>
      <FilterBar onFilterChange={handleFilterChange} currentFilter={filter} />
      <DataList data={processedData} />
      <Summary total={total} />
    </div>
  );
}
```

<details>
<summary>정답 보기</summary>

```javascript
function Dashboard({ data }) {
  const [filter, setFilter] = useState('all');

  // useCallback으로 함수 메모이제이션
  const handleFilterChange = useCallback((newFilter) => {
    setFilter(newFilter);
  }, []);

  // useMemo로 데이터 처리 결과 메모이제이션
  const processedData = useMemo(() => {
    return data
      .filter(item => filter === 'all' || item.type === filter)
      .map(item => ({
        ...item,
        formatted: `${item.name} - ${item.value}`
      }));
  }, [data, filter]);

  // useMemo로 합계 계산 메모이제이션
  const total = useMemo(() => {
    return processedData.reduce((sum, item) => sum + item.value, 0);
  }, [processedData]);

  return (
    <div>
      <FilterBar onFilterChange={handleFilterChange} currentFilter={filter} />
      <DataList data={processedData} />
      <Summary total={total} />
    </div>
  );
}
```

**최적화 포인트**:
1. `handleFilterChange`: useCallback으로 함수 메모이제이션
2. `processedData`: useMemo로 필터링 및 매핑 결과 캐싱
3. `total`: useMemo로 합계 계산 캐싱
</details>

---

## 8. 참고 자료

### 공식 문서
- [React useCallback](https://react.dev/reference/react/useCallback)
- [React useMemo](https://react.dev/reference/react/useMemo)
- [React.memo](https://react.dev/reference/react/memo)

### 추천 읽기
- [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
- [Optimizing Performance (React 공식 가이드)](https://react.dev/learn/render-and-commit)
- [React Performance Optimization](https://blog.logrocket.com/react-performance-optimization/)

---

## 9. 다음 단계

이번 학습에서는 버그 수정과 성능 최적화를 진행했습니다. 다음 단계로는:

1. **React.memo 적용**: 컴포넌트 레벨 최적화
2. **Code Splitting**: 번들 크기 최적화
3. **Lazy Loading**: 필요한 시점에 컴포넌트 로드
4. **Virtualization**: 긴 리스트 성능 최적화

---

**작성 완료일**: 2025-10-15
**적용 파일**:
- `src/App.js`
- `src/pages/CalendarPage.js`
- `src/hooks/useTransactions.js`
- `src/hooks/useFixedExpenses.js`
- `src/services/autoRegisterService.js`
